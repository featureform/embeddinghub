package scheduling

import (
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/featureform/locker"
	ss "github.com/featureform/storage_storer"
)

// type TaskMetadataManager interface {
// 	// Task Methods
// 	CreateTask(name string, tType TaskType, target TaskTarget) (TaskMetadata, error)
// 	GetTask(id TaskID) (TaskMetadata, error)
// 	UpdateTask(id TaskID, metadata TaskMetadata) error

// 	// Task Run Methods
// 	CreateTaskRun(run TaskRunMetadata) error
// 	GetTaskRun(taskId TaskID, runId TaskRunID) (TaskRunMetadata, error)
// 	UpdateTaskRun(taskId TaskID, runId TaskRunID, metadata TaskRunMetadata) error
// 	GetTaskRunLog(taskId TaskID, runId TaskRunID) (string, error)
// 	GetTaskRunError(taskId TaskID, runId TaskRunID) (error, error)

// 	GetAllRunsForTask(taskId TaskID) ([]TaskRunMetadata, error)
// }

type TaskMetadataManager struct {
	// storage ss.MetadataStorer
	storer ss.MetadataStorer
}

func NewMemoryTaskMetadataManager() TaskMetadataManager {
	memoryLocker := locker.MemoryLocker{
		LockedItems: sync.Map{},
		Mutex:       &sync.Mutex{},
	}

	memoryStorer := ss.MemoryStorerImplementation{
		Storage: make(map[string]string),
	}

	memoryMetadataStorer := ss.MetadataStorer{
		Locker: &memoryLocker,
		Storer: &memoryStorer,
	}
	return TaskMetadataManager{
		storer: memoryMetadataStorer,
	}
}

func (m *TaskMetadataManager) CreateTask(name string, tType TaskType, target TaskTarget) (TaskMetadata, error) {
	keys, err := m.storer.List(TaskMetadataKey{}.String())
	if err != nil {
		return TaskMetadata{}, fmt.Errorf("failed to fetch keys: %v", err)
	}

	// This logic could probably be somewhere else
	var latestID int
	if len(keys) == 0 {
		latestID = 0
	} else {
		latestID, err = getLatestId(keys)
		if err != nil {
			return TaskMetadata{}, err
		}
	}

	metadata := TaskMetadata{
		ID:          TaskID(latestID + 1),
		Name:        name,
		TaskType:    tType,
		Target:      target,
		TargetType:  target.Type(),
		DateCreated: time.Now().UTC(),
	}

	// I do this serialize and deserialize a lot in this file. Would be nice to have set and get helpers that deal with
	// all the converting instead
	serializedMetadata, err := metadata.Marshal()
	if err != nil {
		return TaskMetadata{}, fmt.Errorf("failed to marshal metadata: %v", err)
	}

	key := TaskMetadataKey{taskID: metadata.ID}
	err = m.storer.Create(key.String(), string(serializedMetadata))
	if err != nil {
		return TaskMetadata{}, fmt.Errorf("failed to create task metadata: %v", err)
	}

	runs := TaskRuns{
		TaskID: metadata.ID,
		Runs:   []TaskRunSimple{},
	}
	serializedRuns, err := runs.Marshal()
	if err != nil {
		return TaskMetadata{}, err
	}

	taskRunKey := TaskRunKey{taskID: metadata.ID}
	err = m.storer.Create(taskRunKey.String(), string(serializedRuns))
	if err != nil {
		return TaskMetadata{}, fmt.Errorf("failed to create task run metadata: %v", err)
	}

	return metadata, nil
}

func (m *TaskMetadataManager) GetTask(id TaskID) (TaskMetadata, error) {
	key := TaskMetadataKey{taskID: id}.String()
	metadata, err := m.storer.Get(key)
	if err != nil {
		return TaskMetadata{}, err
	}

	// Should enum 0 as EmptyList or something
	if len(metadata) == 0 {
		return TaskMetadata{}, fmt.Errorf("task not found for id: %s", string(id))
	}

	taskMetadata := TaskMetadata{}
	err = taskMetadata.Unmarshal([]byte(metadata))
	if err != nil {
		return TaskMetadata{}, err
	}
	return taskMetadata, nil
}

func (m *TaskMetadataManager) DeleteTask(id TaskID) error {
	// TODO: need to delete the task too and all the runs

	key := TaskMetadataKey{taskID: id}.String()
	_, err := m.storer.Delete(key)
	if err != nil {
		return err
	}

	return nil
}

func (m *TaskMetadataManager) UpdateTask(id TaskID, metadata TaskMetadata) error {
	return fmt.Errorf("not implemented")
}

func (m *TaskMetadataManager) CreateTaskRun(name string, taskID TaskID, trigger Trigger) (TaskRunMetadata, error) {
	// ids will be generated by TM
	taskRunKey := TaskRunKey{taskID: taskID}
	key, err := m.storer.Get(taskRunKey.String())
	if err != nil {
		return TaskRunMetadata{}, fmt.Errorf("failed to fetch task: %v", err)
	}

	// Not sold on this naming for this struct. Maybe like RunHistory or something?
	runs := TaskRuns{}
	err = runs.Unmarshal([]byte(key))
	if err != nil {
		return TaskRunMetadata{}, err
	}

	// This function could be a method of TaskRuns
	latestID, err := getHighestRunID(runs)
	if err != nil {
		return TaskRunMetadata{}, err
	}

	startTime := time.Now().UTC()

	metadata := TaskRunMetadata{
		ID:          TaskRunID(latestID + 1),
		TaskId:      taskID,
		Name:        name,
		Trigger:     trigger,
		TriggerType: trigger.Type(),
		Status:      Pending,
		StartTime:   startTime,
	}

	runs.Runs = append(runs.Runs, TaskRunSimple{RunID: metadata.ID, DateCreated: startTime})

	serializedRuns, err := runs.Marshal()
	if err != nil {
		return TaskRunMetadata{}, err
	}

	serializedMetadata, err := metadata.Marshal()
	if err != nil {
		return TaskRunMetadata{}, fmt.Errorf("failed to marshal metadata: %v", err)
	}

	err = m.storer.Create(taskRunKey.String(), string(serializedRuns))
	if err != nil {
		return TaskRunMetadata{}, fmt.Errorf("failed to create task run metadata: %v", err)
	}

	taskRunMetaKey := TaskRunMetadataKey{taskID: taskID, runID: metadata.ID, date: startTime}
	err = m.storer.Create(taskRunMetaKey.String(), string(serializedMetadata))
	if err != nil {
		return TaskRunMetadata{}, fmt.Errorf("failed to create task run metadata: %v", err)
	}

	return metadata, nil
}

func (m *TaskMetadataManager) GetTaskRun(taskId TaskID, runId TaskRunID) (TaskRunMetadata, error) {
	taskRunKey := TaskRunKey{taskID: taskId}
	key, err := m.storer.Get(taskRunKey.String())
	if err != nil {
		return TaskRunMetadata{}, fmt.Errorf("failed to fetch task: %v", err)
	}

	runs := TaskRuns{}
	err = runs.Unmarshal([]byte(key))
	if err != nil {
		return TaskRunMetadata{}, err
	}

	// Want to move this logic out
	found := false
	var runRecord TaskRunSimple
	for _, run := range runs.Runs {
		if run.RunID == runId {
			runRecord = run
			found = true
			break
		}
	}
	if !found {
		return TaskRunMetadata{}, fmt.Errorf("run not found")
	}

	date := runRecord.DateCreated
	taskRunMetadataKey := TaskRunMetadataKey{taskID: taskId, runID: runRecord.RunID, date: date}
	rec, err := m.storer.Get(taskRunMetadataKey.String())
	if err != nil {
		return TaskRunMetadata{}, err
	}

	taskRun := TaskRunMetadata{}
	err = taskRun.Unmarshal([]byte(rec))
	if err != nil {
		return TaskRunMetadata{}, fmt.Errorf("failed to unmarshal run record: %v", err)
	}
	return taskRun, nil
}

func (m *TaskMetadataManager) UpdateTaskRun(taskId TaskID, runId TaskRunID, metadata TaskRunMetadata) error {
	return fmt.Errorf("not implemented")
}

func (m *TaskMetadataManager) GetTaskRunLog(taskId TaskID, runId TaskRunID) (string, error) {
	return "", fmt.Errorf("not implemented")
}

func (m *TaskMetadataManager) GetTaskRunError(taskId TaskID, runId TaskRunID) (error, error) {
	return nil, fmt.Errorf("not implemented")
}

func (m *TaskMetadataManager) GetAllRunsForTask(taskId TaskID) ([]TaskRunMetadata, error) {
	return nil, fmt.Errorf("not implemented")
}

// Finds the highest increment in a list of strings formatted like "/tasks/metadata/task_id=0"
func getLatestId(taskMetadata map[string]string) (int, error) {
	highestIncrement := -1
	for path, _ := range taskMetadata {
		parts := strings.Split(path, "task_id=")
		if len(parts) < 2 {
			return -1, fmt.Errorf("invalid format for path: %s", path)
		}
		increment, err := strconv.Atoi(parts[1])
		if err != nil {
			return -1, fmt.Errorf("failed to convert task_id to integer: %s", err)
		}
		if increment > highestIncrement {
			highestIncrement = increment
		}
	}
	if highestIncrement == -1 {
		return -1, fmt.Errorf("no valid increments found")
	}
	return highestIncrement, nil
}
