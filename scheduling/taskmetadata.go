package scheduling

import (
	"fmt"
	"regexp"
	"strconv"
	"sync"
	"time"

	"github.com/featureform/fferr"
	"github.com/featureform/locker"
	ss "github.com/featureform/storage"
)

type TaskMetadataList []TaskMetadata

type TaskRunList []TaskRunMetadata

func (trl *TaskRunList) FilterByStatus(status Status) {
	var newList TaskRunList
	for _, run := range *trl {
		if run.Status == status {
			newList = append(newList, run)
		}
	}
	*trl = newList
}

type TaskMetadataManager struct {
	storer ss.MetadataStorer
}

func NewMemoryTaskMetadataManager() TaskMetadataManager {
	memoryLocker := locker.MemoryLocker{
		LockedItems: sync.Map{},
		Mutex:       &sync.Mutex{},
	}

	memoryStorer := ss.MemoryStorerImplementation{
		Storage: make(map[string]string),
	}

	memoryMetadataStorer := ss.MetadataStorer{
		Locker: &memoryLocker,
		Storer: &memoryStorer,
	}
	return TaskMetadataManager{
		storer: memoryMetadataStorer,
	}
}

func (m *TaskMetadataManager) CreateTask(name string, tType TaskType, target TaskTarget) (TaskMetadata, fferr.GRPCError) {
	keys, err := m.storer.List(TaskMetadataKey{}.String())
	if err != nil {
		err.AddDetail("metadata type", "task metadata")
		err.AddDetail("task name", name)
		err.AddDetail("task type", string(tType))
		return TaskMetadata{}, err
	}

	// This logic could probably be somewhere else
	var latestID int
	if len(keys) == 0 {
		latestID = 0
	} else {
		latestID, err = getLatestId(keys)
		if err != nil {
			return TaskMetadata{}, err
		}
	}

	metadata := TaskMetadata{
		ID:          TaskID(latestID + 1),
		Name:        name,
		TaskType:    tType,
		Target:      target,
		TargetType:  target.Type(),
		DateCreated: time.Now().UTC(),
	}

	// I do this serialize and deserialize a lot in this file. Would be nice to have set and get helpers that deal with
	// all the converting instead
	serializedMetadata, err := metadata.Marshal()
	if err != nil {
		return TaskMetadata{}, err
	}

	key := TaskMetadataKey{taskID: metadata.ID}
	err = m.storer.Create(key.String(), string(serializedMetadata))
	if err != nil {
		return TaskMetadata{}, err
	}

	runs := TaskRuns{
		TaskID: metadata.ID,
		Runs:   []TaskRunSimple{},
	}
	serializedRuns, err := runs.Marshal()
	if err != nil {
		return TaskMetadata{}, err
	}

	taskRunKey := TaskRunKey{taskID: metadata.ID}
	err = m.storer.Create(taskRunKey.String(), string(serializedRuns))
	if err != nil {
		err.AddDetail("task_id", string(metadata.ID))
		return TaskMetadata{}, err
	}

	return metadata, nil
}

func (m *TaskMetadataManager) GetTaskByID(id TaskID) (TaskMetadata, fferr.GRPCError) {
	key := TaskMetadataKey{taskID: id}.String()
	metadata, err := m.storer.Get(key)
	if err != nil {
		return TaskMetadata{}, err
	}

	// Should enum 0 as EmptyList or something
	if len(metadata) == 0 {
		return TaskMetadata{}, fferr.NewInternalError(fmt.Errorf("task not found for id: %s", string(id)))
	}

	taskMetadata := TaskMetadata{}
	err = taskMetadata.Unmarshal([]byte(metadata))
	if err != nil {
		return TaskMetadata{}, err
	}
	return taskMetadata, nil
}

func (m *TaskMetadataManager) GetAllTasks() (TaskMetadataList, fferr.GRPCError) {
	metadata, err := m.storer.List(TaskMetadataKey{}.String())
	if err != nil {
		return TaskMetadataList{}, err
	}

	tml, err := m.getAllTasksAsMetadataList(metadata)
	if err != nil {
		return TaskMetadataList{}, err
	}
	return tml, nil
}

func (m *TaskMetadataManager) getAllTasksAsMetadataList(metadata map[string]string) (TaskMetadataList, fferr.GRPCError) {
	tml := TaskMetadataList{}
	for _, meta := range metadata {
		taskMetadata := TaskMetadata{}
		err := taskMetadata.Unmarshal([]byte(meta))
		if err != nil {
			return TaskMetadataList{}, err
		}
		tml = append(tml, taskMetadata)
	}
	return tml, nil
}

func (m *TaskMetadataManager) CreateTaskRun(name string, taskID TaskID, trigger Trigger) (TaskRunMetadata, fferr.GRPCError) {
	// ids will be generated by TM
	taskRunKey := TaskRunKey{taskID: taskID}
	taskMetadata, err := m.storer.Get(taskRunKey.String())
	if err != nil {
		err.AddDetail("task name", name)
		return TaskRunMetadata{}, err
	}

	// Not sold on this naming for this struct. Maybe like RunHistory or something?
	runs := TaskRuns{}
	err = runs.Unmarshal([]byte(taskMetadata))
	if err != nil {
		err.AddDetail("task name", name)
		err.AddDetail("task_id", string(taskID))
		return TaskRunMetadata{}, err
	}

	latestID, err := runs.GetLatestRunId()
	if err != nil {
		err.AddDetail("task name", name)
		err.AddDetail("task_id", string(taskID))
		return TaskRunMetadata{}, err
	}

	startTime := time.Now().UTC()

	metadata := TaskRunMetadata{
		ID:          TaskRunID(latestID + 1),
		TaskId:      taskID,
		Name:        name,
		Trigger:     trigger,
		TriggerType: trigger.Type(),
		Status:      Pending,
		StartTime:   startTime,
	}

	runs.Runs = append(runs.Runs, TaskRunSimple{RunID: metadata.ID, DateCreated: startTime})

	serializedRuns, err := runs.Marshal()
	if err != nil {
		err.AddDetail("task name", name)
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(metadata.ID))
		return TaskRunMetadata{}, err
	}

	serializedMetadata, err := metadata.Marshal()
	if err != nil {
		err.AddDetail("task name", name)
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(metadata.ID))
		return TaskRunMetadata{}, err
	}
	err = m.storer.Create(taskRunKey.String(), string(serializedRuns))
	if err != nil {
		err.AddDetail("task name", name)
		err.AddDetail("task_id", string(taskID))
		return TaskRunMetadata{}, err
	}

	taskRunMetaKey := TaskRunMetadataKey{taskID: taskID, runID: metadata.ID, date: startTime}
	err = m.storer.Create(taskRunMetaKey.String(), string(serializedMetadata))
	if err != nil {
		err.AddDetail("task name", name)
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(metadata.ID))
		return TaskRunMetadata{}, err
	}

	return metadata, nil
}

func (m *TaskMetadataManager) GetRunByID(taskID TaskID, runID TaskRunID) (TaskRunMetadata, fferr.GRPCError) {
	taskRunKey := TaskRunKey{taskID: taskID}
	taskRunMetadata, err := m.storer.Get(taskRunKey.String())
	if err != nil {
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return TaskRunMetadata{}, err
	}

	runs := TaskRuns{}
	err = runs.Unmarshal([]byte(taskRunMetadata))
	if err != nil {
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return TaskRunMetadata{}, err
	}

	// Want to move this logic out
	found, runRecord := runs.ContainsRun(runID)
	if !found {
		err := fferr.NewKeyNotFoundError(taskRunKey.String(), fmt.Errorf("run not found"))
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return TaskRunMetadata{}, err
	}

	date := runRecord.DateCreated
	taskRunMetadataKey := TaskRunMetadataKey{taskID: taskID, runID: runRecord.RunID, date: date}
	rec, err := m.storer.Get(taskRunMetadataKey.String())
	if err != nil {
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return TaskRunMetadata{}, err
	}

	taskRun := TaskRunMetadata{}
	err = taskRun.Unmarshal([]byte(rec))
	if err != nil {
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return TaskRunMetadata{}, err
	}
	return taskRun, nil
}

func (m *TaskMetadataManager) GetRunsByDate(start time.Time, end time.Time) (TaskRunList, fferr.GRPCError) {
	// the date range is inclusive
	var runs []TaskRunMetadata

	// iterate through each day in the date range including the end date
	for date := start; date.Before(end) || date.Equal(end); date = date.AddDate(0, 0, 1) {
		dayRuns, err := m.getRunsForDay(date, start, end)
		if err != nil {
			return []TaskRunMetadata{}, err
		}
		runs = append(runs, dayRuns...)
	}

	return runs, nil
}

func (m *TaskMetadataManager) getRunsForDay(date time.Time, start time.Time, end time.Time) ([]TaskRunMetadata, fferr.GRPCError) {
	key := TaskRunMetadataKey{date: date}
	recs, err := m.storer.List(key.String())
	if err != nil {
		err.AddDetail("date", date.String())
		return []TaskRunMetadata{}, err
	}

	var runs []TaskRunMetadata
	for _, record := range recs {
		taskRun := TaskRunMetadata{}
		err = taskRun.Unmarshal([]byte(record))
		if err != nil {
			return []TaskRunMetadata{}, err
		}

		// if the task run started before the start time or after the end time, skip it
		if taskRun.StartTime.Before(start) || taskRun.StartTime.After(end) {
			continue
		}
		runs = append(runs, taskRun)
	}
	return runs, nil
}

func (m *TaskMetadataManager) GetAllTaskRuns() (TaskRunList, fferr.GRPCError) {
	recs, err := m.storer.List(TaskRunMetadataKey{}.String())
	if err != nil {
		return []TaskRunMetadata{}, err
	}

	var runs []TaskRunMetadata
	for _, record := range recs {
		taskRun := TaskRunMetadata{}
		err = taskRun.Unmarshal([]byte(record))
		if err != nil {
			return []TaskRunMetadata{}, err
		}
		runs = append(runs, taskRun)
	}
	return runs, nil
}

func (m *TaskMetadataManager) SetRunStatus(runID TaskRunID, taskID TaskID, status Status, err error) fferr.GRPCError {
	if taskID <= 0 {
		e := fferr.NewInvalidArgumentError(fmt.Errorf("task id needs to be greater than 0"))
		e.AddDetail("task_id", string(taskID))
		return e
	}

	metadata, e := m.GetRunByID(taskID, runID)
	if e != nil {
		e.AddDetail("task_id", string(taskID))
		e.AddDetail("run_id", string(runID))
		return e
	}

	updateStatus := func(runMetadata string) (string, fferr.GRPCError) {
		metadata := TaskRunMetadata{}
		unmarshalErr := metadata.Unmarshal([]byte(runMetadata))
		if unmarshalErr != nil {
			e := fferr.NewInternalError(unmarshalErr)
			e.AddDetail("task_id", string(taskID))
			e.AddDetail("run_id", string(runID))
			return "", e
		}
		if status == Failed && err == nil {
			e := fferr.NewInvalidArgumentError(fmt.Errorf("error is required for failed status"))
			e.AddDetail("task_id", string(taskID))
			e.AddDetail("run_id", string(runID))
			e.AddDetail("status", string(status))
			return "", e
		}
		metadata.Status = status
		if err == nil {
			metadata.Error = ""
		} else {
			metadata.Error = err.Error()
		}

		serializedMetadata, marshalErr := metadata.Marshal()
		if marshalErr != nil {
			marshalErr.AddDetail("task_id", string(taskID))
			marshalErr.AddDetail("run_id", string(runID))
			return "", e
		}

		return string(serializedMetadata), nil
	}

	taskRunMetadataKey := TaskRunMetadataKey{taskID: taskID, runID: metadata.ID, date: metadata.StartTime}
	e = m.storer.Update(taskRunMetadataKey.String(), updateStatus)
	return e
}

func (m *TaskMetadataManager) SetRunEndTime(runID TaskRunID, taskID TaskID, time time.Time) fferr.GRPCError {
	if taskID <= 0 {
		errMessage := fmt.Errorf("task id has to be greater than 0")
		err := fferr.NewInvalidArgumentError(errMessage)
		err.AddDetail("task_id", string(taskID))
		return err
	}
	if time.IsZero() {
		errMessage := fmt.Errorf("end time cannot be zero")
		err := fferr.NewInvalidArgumentError(errMessage)
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		err.AddDetail("end_time", time.String())
		return err
	}

	metadata, e := m.GetRunByID(taskID, runID)
	if e != nil {
		e.AddDetail("task_id", string(taskID))
		e.AddDetail("run_id", string(runID))
		return e
	}

	updateEndTime := func(runMetadata string) (string, fferr.GRPCError) {
		metadata := TaskRunMetadata{}
		err := metadata.Unmarshal([]byte(runMetadata))
		if err != nil {
			err.AddDetail("task_id", string(taskID))
			err.AddDetail("run_id", string(runID))
			return "", err
		}

		if metadata.StartTime.After(time) {
			err := fferr.NewInvalidArgumentError(fmt.Errorf("end time cannot be before start time"))
			err.AddDetail("task_id", string(taskID))
			err.AddDetail("run_id", string(runID))
			err.AddDetail("start_time", metadata.StartTime.String())
			err.AddDetail("end_time", time.String())
			return "", err
		}

		metadata.EndTime = time
		serializedMetadata, e := metadata.Marshal()
		if e != nil {
			return "", e
		}

		return string(serializedMetadata), nil
	}

	taskRunMetadataKey := TaskRunMetadataKey{taskID: taskID, runID: metadata.ID, date: metadata.StartTime}
	e = m.storer.Update(taskRunMetadataKey.String(), updateEndTime)
	return e
}

func (m *TaskMetadataManager) AppendRunLog(runID TaskRunID, taskID TaskID, log string) fferr.GRPCError {
	if runID <= 0 {
		err := fferr.NewInvalidArgumentError(fmt.Errorf("run id has to be greater than 0"))
		err.AddDetail("run_id", string(runID))
		err.AddDetail("task_id", string(taskID))
		return err
	}
	if taskID <= 0 {
		err := fferr.NewInvalidArgumentError(fmt.Errorf("task id has to be greater than 0"))
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return err
	}
	if log == "" {
		err := fferr.NewInvalidArgumentError(fmt.Errorf("log cannot be empty"))
		err.AddDetail("task_id", string(taskID))
		err.AddDetail("run_id", string(runID))
		return err
	}

	metadata, e := m.GetRunByID(taskID, runID)
	if e != nil {
		return e
	}

	updateLog := func(runMetadata string) (string, fferr.GRPCError) {
		metadata := TaskRunMetadata{}
		err := metadata.Unmarshal([]byte(runMetadata))
		if err != nil {
			return "", err
		}

		metadata.Logs = append(metadata.Logs, log)

		serializedMetadata, e := metadata.Marshal()
		if e != nil {
			return "", err
		}

		return string(serializedMetadata), nil
	}

	taskRunMetadataKey := TaskRunMetadataKey{taskID: taskID, runID: metadata.ID, date: metadata.StartTime}
	e = m.storer.Update(taskRunMetadataKey.String(), updateLog)
	return e
}

// Finds the highest increment in a list of strings formatted like "/tasks/metadata/task_id=0"
func getLatestId(taskMetadata map[string]string) (int, fferr.GRPCError) {
	highestTaskId := -1

	// Regular expression pattern to match "task_id=<number>"
	pattern := regexp.MustCompile(`/tasks/metadata/task_id=(\d+)`)

	for path, _ := range taskMetadata {
		increment, err := getTaskIdFromPath(pattern, path)
		if err != nil {
			return -1, err
		}

		if increment > highestTaskId {
			highestTaskId = increment
		}
	}
	if highestTaskId == -1 {
		errMessage := fmt.Errorf("no task metadata found")
		err := fferr.NewInternalError(errMessage)
		return -1, err
	}
	return highestTaskId, nil
}

func getTaskIdFromPath(pattern *regexp.Regexp, path string) (int, fferr.GRPCError) {
	matches := pattern.FindStringSubmatch(path)
	if len(matches) < 2 {
		errMessage := fmt.Errorf("invalid format for path: %s", path)
		err := fferr.NewInvalidArgumentError(errMessage)
		err.AddDetail("path", path)
		err.AddDetail("expected format", "/tasks/metadata/task_id=0")
		return -1, err
	}
	taskId, err := strconv.Atoi(matches[1])
	if err != nil {
		errMessage := fmt.Errorf("failed to convert task_id to integer: %s", err)
		err := fferr.NewInternalError(errMessage)
		err.AddDetail("task_id", matches[1])
		return -1, err
	}

	return taskId, nil
}
